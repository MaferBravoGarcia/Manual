?refseq
?refseq()
install.packages(codyn)
install.packages("codyn")
install.packages("RADanalysis")
install.packages(c("aplot", "bit", "bookdown", "boot", "data.table", "datawizard", "epimdr2", "evaluate", "flextable", "ggfun", "ggpubr", "ggrepel", "ggspatial", "ggstance", "graphlayouts", "Hmisc", "insight", "jsonify", "knitr", "lubridate", "markdown", "Matrix", "matrixStats", "mc2d", "modelr", "parameters", "pbapply", "pkgload", "plotly", "plyr", "polspline", "randtoolbox", "RcppArmadillo", "RcppEigen", "rgdal", "rmarkdown", "rngWELL", "roxygen2", "RSQLite", "rstatix", "s2", "sass", "sf", "sfsmisc", "smacpod", "sp", "spatstat", "spatstat.linnet", "spData", "statsExpressions", "terra", "vctrs", "xaringan", "xfun"))
install.packages(c("aplot", "bit", "bookdown", "boot", "data.table", "datawizard", "epimdr2", "evaluate", "flextable", "ggfun", "ggpubr", "ggrepel", "ggspatial", "ggstance", "graphlayouts", "Hmisc", "insight", "jsonify", "knitr", "lubridate", "markdown", "Matrix", "matrixStats", "mc2d", "modelr", "parameters", "pbapply", "pkgload", "plotly", "plyr", "polspline", "randtoolbox", "RcppArmadillo", "RcppEigen", "rgdal", "rmarkdown", "rngWELL", "roxygen2", "RSQLite", "rstatix", "s2", "sass", "sf", "sfsmisc", "smacpod", "sp", "spatstat", "spatstat.linnet", "spData", "statsExpressions", "terra", "vctrs", "xaringan", "xfun"))
install.packages(c("aplot", "bit", "bookdown", "boot", "data.table", "datawizard", "epimdr2", "evaluate", "flextable", "ggfun", "ggpubr", "ggrepel", "ggspatial", "ggstance", "graphlayouts", "Hmisc", "insight", "jsonify", "knitr", "lubridate", "markdown", "Matrix", "matrixStats", "mc2d", "modelr", "parameters", "pbapply", "pkgload", "plotly", "plyr", "polspline", "randtoolbox", "RcppArmadillo", "RcppEigen", "rgdal", "rmarkdown", "rngWELL", "roxygen2", "RSQLite", "rstatix", "s2", "sass", "sf", "sfsmisc", "smacpod", "sp", "spatstat", "spatstat.linnet", "spData", "statsExpressions", "terra", "vctrs", "xaringan", "xfun"))
install.packages(c("aplot", "bit", "bookdown", "boot", "data.table", "datawizard", "epimdr2", "evaluate", "flextable", "ggfun", "ggpubr", "ggrepel", "ggspatial", "ggstance", "graphlayouts", "Hmisc", "insight", "jsonify", "knitr", "lubridate", "markdown", "Matrix", "matrixStats", "mc2d", "modelr", "parameters", "pbapply", "pkgload", "plotly", "plyr", "polspline", "randtoolbox", "RcppArmadillo", "RcppEigen", "rgdal", "rmarkdown", "rngWELL", "roxygen2", "RSQLite", "rstatix", "s2", "sass", "sf", "sfsmisc", "smacpod", "sp", "spatstat", "spatstat.linnet", "spData", "statsExpressions", "terra", "vctrs", "xaringan", "xfun"))
install.packages(c("aplot", "ggspatial", "graphlayouts", "insight", "mc2d", "modelr", "parameters", "pbapply", "pkgload", "plotly", "plyr", "polspline", "randtoolbox", "RcppArmadillo", "RcppEigen", "rgdal", "rmarkdown", "rngWELL", "roxygen2", "RSQLite", "rstatix", "s2", "sass", "sf", "sfsmisc", "smacpod", "sp", "spatstat", "spatstat.linnet", "spData", "statsExpressions", "terra", "vctrs", "xaringan", "xfun"))
install.packages(c("aplot", "ggspatial", "graphlayouts", "insight", "mc2d", "modelr", "parameters", "pbapply", "pkgload", "plotly", "plyr", "polspline", "randtoolbox", "RcppArmadillo", "RcppEigen", "rgdal", "rmarkdown", "rngWELL", "roxygen2", "RSQLite", "rstatix", "s2", "sass", "sf", "sfsmisc", "smacpod", "sp", "spatstat", "spatstat.linnet", "spData", "statsExpressions", "terra", "vctrs", "xaringan", "xfun"))
4*8
3^3 + (8-10^2) - (25/sqrt(25))^2
1/(3^-3) + (8-10^2) - (25/sqrt(25))^2
1 < 5
log(20) < sqrt(4)
v = c(1:5)
v}
v
f = c(3:10)
f
which(v==f)
v == f
f = c(3:8)
v == f
f = c(3:7)
v == f
v
f
v != f
which(f == v)
c[3:5]
v
f
v[3] == f[1]
v
f
v[3] == f[2]
v == f
v[1:5] == f[1:5]
1 + 2*3 + 3 + 15/3
4 - 15/3 + 3^2 + 3*sqrt(81)
1/3^-1
3/1^-1
(-2)^2
(2)^2
x<- "La candente mañana de febrero en que Beatriz Viterbo murió, después de una imperiosa agonía que no se rebajó un solo instante ni al sentimentalismo ni al miedo"
x
x <- la candente
?class
x <- 1
class(x)
x <- 1:3
class(x)
type
?c()
s <- (1:5)
length(s)
x<-c
x[c(1,3,5,7)]
x <- c("Hola", "Bien", "cómo", "¡", "estás", ":(", "?")
x[c(1,3,5,7)]
#Se define el vector "x"
x <- c("Hola", "Bien", "cómo", "!", "estás", ":(", "?")
#Se indica dentro de un vector que se seleccionen las posiciones 1, 3, 5 y 7 del vector "x".
x[c(1,3,5,7)]
x[c("Hola","!")]
x<-c(1,2,3,5,8,13,21)
x[c(2, 7, 4)]
x[c("1","3")]
x<-c(1,2,3,5,8,13,21)
x[c(2, 7, 4)]
#Se define el vector "x"
x <- c("Hola", "Bien", "cómo", "!", "estás", ":(", "?")
#Se indica dentro de un vector que se seleccionen las posiciones 1, 3, 5 y 7 del vector "x".
x[c(1,3,5,7)]
#Se define el vector "x"
x <- c(1,2,3,5,8,13,21)
x[-4]
#Se define el vector "x"
x <- c(1,2,3,5,8,13,21)
#Dentro del corchete indicamos la posición que se quiere omitir
x[-4]
#Se define el vector "x"
x <- c(1,2,3,5,8,13,21)
#Dentro del corchete indicamos la posición que se quiere omitir
x[-4]
#Cuando se quiere omitir un conjunto de posiciones, se definen dentro de un vector
x[-c(2, 7, 4)]   # Todos menos el segundo , séptimo y cuarto elemento
x<-c(1,2,3,5,8,13,21)
x[-6]
x     # Estoy intacto
x <- c(1,2,3,5,8,13,21)
x[-6]
x     # Estoy intacto
#Se define el vector "x"
x <- c(88,5,12,13)
#
x <- c(x[1:3],168,x[4])
x
x<-c()
x                 # Soy un vector vacío :(
x[1]<- 2
x[2:5]<-c(56,78,90,12)
x                 # Ahora ya no :)
#Repite 5 veces el valor "3" y asignalo a la variable "x".
x<-rep(3,5)
x
y<-rep(c(1,2,3,5),3)
y
x<-c(1,2,3,4)
y<-rep(x,each=2)
y
x <- 1:15
any(x > 7.5)
all(x> sqrt(100))
x<-c(1,2,3)
y<-c(4,5,6)
x + y
x-y
x*x
y*y
x*y
3*x                #Multiplicación por escalar: término a término
sqrt(2)*y          # Sí, por cualquier escalar!
3*x + sqrt(2)*y    # Operaciones más complejas
x<-c(1,2,3)
y<-c(4,5,6)
x + y
x-y
x*x
y*y
x*y
x/y
3*x                #Multiplicación por escalar: término a término
sqrt(2)*y          # Sí, por cualquier escalar!
3*x + sqrt(2)*y    # Operaciones más complejas
x<-c(1,2,3)
y<-c(4,5,6)
x + y
x-y
x*x
y*y
x*y
x/y
sqrt(x)
3*x                #Multiplicación por escalar: término a término
sqrt(2)*y          # Sí, por cualquier escalar!
3*x + sqrt(2)*y    # Operaciones más complejas
x<-c(1,2,3)
y<-c(4,5,6)
x + y
x-y
x*x
y*y
x*y
x/y
sqrt(x)
x^2
3*x                #Multiplicación por escalar: término a término
sqrt(2)*y          # Sí, por cualquier escalar!
3*x + sqrt(2)*y    # Operaciones más complejas
x * x
x * y
x ** y
x ** y
y ^ 2
x + y
x + 2
x / y
y / 5
log(x)
z = c(1:10)
z
sum(z)
#Respuesta muy larga
(1+2+3+4+5+6+7+8+9+10)/10
#Se define el vector que incluye valores del 1 al 1000
x<-rnorm(1000)
min(x) #
max(x)
range(x)
sum(x)
mean(x)
median(x)
sd(x)
quantile(x)
#Se define el vector que incluye valores del 1 al 1000
x<-rnorm(1000)
min(x) #
max(x)
range(x)
sum(x)
mean(x)
median(x)
sd(x)
quantile(x)
#Se define el vector que incluye valores del 1 al 1000
x<-rnorm(1000)
x
min(x) #
max(x)
range(x)
sum(x)
mean(x)
median(x)
sd(x)
quantile(x)
x<- c(rep(3,5),1:15,rep(c(1,2,3),5))
unique(x)
x<-sample(10,10)
x
sort(x)
x<- rnorm(10000)
hist(x,col="tomato2") #Histograma
plot(x,col="salmon")
boxplot(x,col="wheat")
edades <- c(35,35,70,17,14) #Definimos un vector llamado "edades"
nombres <- c("Jerry","Beth","Rick", "Summer","Morty") #Definimos un vector llamado "edades", del mismo tamaño que "edades"
names(edades) <- nombres #Se nombran los elementos del vector "edades"
nombres
edades <- c(35,35,70,17,14) #Definimos un vector llamado "edades"
nombres <- c("Jerry","Beth","Rick", "Summer","Morty") #Definimos un vector llamado "edades", del mismo tamaño que "edades"
names(edades) <- nombres #Se nombran los elementos del vector "edades"
edades
Ahora veamos un ejemplo más "biológico"
genomeSizeM_BP<-c(3234.83,2716.97,143.73,0.014281,12.1)
genomeSizeM_BP*1e6
organismo<-c("Human","Mouse","Fruit Fly","Roundworm","Yeast")
names(genomeSizeM_BP)<- organismo
genomeSizeM_BP
y <- matrix(c(1,5,8,-4), nrow=2, ncol=2) #nrow: indica el número de renglones & ncol: indica el número de columnas.
y
y[1,2]
y[1,]
ventas <- data.frame(
mes = c("enero", "febrero", "marzo", "abril"),
productos_vendidos = c(10, 15, 20, 25),
ingresos = c(100, 150, 200, 250)
)
ventas <- data.frame(
mes = c("enero", "febrero", "marzo", "abril"),
productos_vendidos = c(10, 15, 20, 25),
ingresos = c(100, 150, 200, 250)
)
print(ventas)
dna_data[2, "secuencia"]
ventas <- data.frame(
mes = c("enero", "febrero", "marzo", "abril"),
productos_vendidos = c(10, 15, 20, 25),
ingresos = c(100, 150, 200, 250)
)
dna_data <- data.frame(
secuencia = c("ATCGATCG", "GCTAGCTA", "TTAAGGCT"),
tamaño = c(8, 8, 8),
contenido_GC = c(0.5, 0.4, 0.3)
)
dna_data[2, "secuencia"]
ventas <- data.frame(
mes = c("enero", "febrero", "marzo", "abril"),
productos_vendidos = c(10, 15, 20, 25),
ingresos = c(100, 150, 200, 250)
)
dna_data <- data.frame(
secuencia = c("ATCGATCG", "GCTAGCTA", "TTAAGGCT"),
tamaño = c(8, 8, 8),
contenido_GC = c(0.5, 0.4, 0.3)
)
print(dna_data)
dna_data[1:2, c("tamaño", "contenido_GC")]
complement <- function(sequence) {
complementary_nucleotides <- c("T", "A", "G", "C")
complement_sequence <- gsub(
pattern = paste(complementary_nucleotides, collapse = "|"),
replacement = complementary_nucleotides,
x = sequence,
ignore.case = TRUE
)
return(complement_sequence)
}
# Original DNA sequences
original_sequences <- c("ATCGATCG", "GCTAGCTA", "TTAAGGCT")
# Finding the complementary chains
complementary_sequences <- lapply(original_sequences, complement)
complement <- function(sequence) {
complementary_nucleotides <- c("T", "A", "G", "C")
complement_sequence <- gsub(
pattern = paste(complementary_nucleotides, collapse = "|"),
replacement = complementary_nucleotides,
x = sequence,
ignore.case = TRUE
)
return(complement_sequence)
}
# Original DNA sequences
original_sequences <- c("ATCGATCG", "GCTAGCTA", "TTAAGGCT")
# Finding the complementary chains
complementary_sequences <- lapply(original_sequences, complement)
original_sequences <- c("ATCGATCG", "GCTAGCTA", "TTAAGGCT")
complementary_sequences <- lapply(original_sequences, complement)
complement("ATCGATCG")
complement(ATCGATCG)
complement("ATCGATCG")
install.packages("bookdown")
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
pwd
getwd()
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
tinytex::install_tinytex()
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
pdf_book(toc = TRUE, number_sections = TRUE, fig_caption = TRUE,
pandoc_args = NULL, ..., base_format = rmarkdown::pdf_document,
toc_unnumbered = TRUE, toc_appendix = FALSE, toc_bib = FALSE,
quote_footer = NULL, highlight_bw = FALSE)
#Repite 5 veces el valor "3" y asignalo a la variable "x"
x <- rep(3,5)
x
#También se pueden repetir un conjunto de valores una vez que sean colocados dentro de un vector
y <- rep(c(1,2,3,5),3) #Repite 3 veces los valores 1, 2, 3 y 5.
y
primos <- c(1,2,3,5,7,11)
z <- rep(primos,4)
z
# Secuencias de ADN
secuencias <- c("ATCGATCG", "GCTAGCTA", "TATATATA")
# Función para detectar secuencias específicas
detectar_motivo <- function(secuencia, motivo) {
any(str_detect(secuencia, motivo))
}
# Motivo a detectar
motivo <- "AGCT"
# Detección de secuencias con el motivo
secuencias_con_motivo <- secuencias[sapply(secuencias, detectar_motivo, motivo)]
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
lobrary(ggplot2)
library(ggplot2)
ggplot(data = mtcars, aes(x = wt, y = mpg)) +
geom_point() +
labs(title = "Consumo de Gasolina vs. Peso",
x = "Peso (1000 lbs)",
y = "Millas por Galón (mpg)")
ggplot(data = mtcars, aes(x = wt, y = mpg, color = factor(gear))) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "Consumo de Gasolina vs. Peso por Tipo de Cambio",
x = "Peso (1000 lbs)",
y = "Millas por Galón (mpg)",
color = "Tipo de Cambio") +
theme_minimal()
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
geom_point() +
labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
x = "Largo del Sépalo",
y = "Ancho del Sépalo")
ggplot(data = iris, aes(x = Sepal.Length)) +
geom_histogram(binwidth = 0.5, fill = "blue") +
labs(title = "Distribución del L
ggplot(data = iris, aes(x = Sepal.Length)) +
geom_histogram(binwidth = 0.5, fill = "blue") +
labs(title = "Distribución del Largo del Sépalo",
x = "Largo del Sépalo",
y = "Frecuencia")
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
bookdown::render_book('index.Rmd', 'bookdown::pdf_book')
# Cargar paquetes necesarios
library(dplyr)
# Generar datos simulados
set.seed(123) # Para reproducibilidad
n_genes = 1000
n_samples = 50
data_control = matrix(rnorm(n_genes * n_samples, mean=10, sd=2), ncol=n_samples)
data_treatment = matrix(rnorm(n_genes * n_samples, mean=10, sd=2), ncol=n_samples)
colnames(data_control) <- paste0("Control_", 1:n_samples)
colnames(data_treatment) <- paste0("Treatment_", 1:n_samples)
rownames(data_control) <- paste0("Gene_", 1:n_genes)
rownames(data_treatment) <- paste0("Gene_", 1:n_genes)
# Algunos genes tendrán diferencias entre grupos para simular genes diferencialmente expresados
differential_genes <- sample(1:n_genes, 100) # 100 genes serán diferencialmente expresados
data_treatment[differential_genes, ] <- data_treatment[differential_genes, ] + rnorm(length(differential_genes))
# Realizar pruebas t para cada gen
p_values <- apply(rbind(data_control, data_treatment), 1, function(x) {
t.test(x[1:n_samples], x[(n_samples + 1):(2*n_samples)])$p.value
})
# Aplicar la corrección de Benjamini-Hochberg
p_adjusted <- p.adjust(p_values, method = "BH")
# Identificar genes significativos
significant_genes <- which(p_adjusted < 0.05)
# Resultados
cat("Número de genes significativos después de la corrección BH:", length(significant_genes), "\n")
# Función para convertir un símbolo ASCII en calidad Phred
convertirASimboloPhred <- function(simbolo) {
# Convertir el símbolo a su valor ASCII
valor_ascii <- as.integer(charToRaw(simbolo))
# Convertir el valor ASCII a calidad Phred (Phred+33)
calidad_phred <- valor_ascii - 33
# Retornar el valor Phred
return(calidad_phred)
}
# Ejemplo de uso
simbolo <- "I" # Cambia esto por el símbolo que desees convertir
calidad_phred <- convertirASimboloPhred(simbolo)
cat(sprintf("El símbolo '%s' corresponde a una calidad Phred de %d.\n", simbolo, calidad_phred))
#
convertirASimboloPhred <- function(simbolo) {
#
valor_ascii <- as.integer(charToRaw(simbolo))
#
calidad_phred <- valor_ascii - 33
# Retornar el valor Phred
return(calidad_phred)
}
# Ejemplo de uso
simbolo <- "I" # Cambia esto por el símbolo que desees convertir
calidad_phred <- convertirASimboloPhred(simbolo)
cat(sprintf("El símbolo '%s' corresponde a una calidad Phred de %d.\n", simbolo, calidad_phred))
# install.packages("devtools")
devtools::install_github("jbengler/tidyheatmaps")
library(tidyheatmaps)
tidyheatmap(data_exprs,
rows = external_gene_name,
columns = sample,
values = expression,
scale = "row",
annotation_col = c(sample_type, condition, group),
annotation_row = c(is_immune_gene, direction),
gaps_row = direction,
gaps_col = group
)
View(data_exprs)
install.packages(c("bookdown", "curl", "data.table", "ggside", "locfit", "RcppArmadillo", "rmarkdown", "systemfonts"))
install.packages(c("bookdown", "curl", "data.table", "ggside", "locfit", "RcppArmadillo", "rmarkdown", "systemfonts"))
install.packages(c("bookdown", "curl", "data.table", "ggside", "locfit", "RcppArmadillo", "rmarkdown", "systemfonts"))
install.packages("zipfR")
library(zipfR)
data(Dickens.spc)
Dickens.emp.vgc
Dickens.spc
tfl1 <- spc2tfl(BrownImag.spc)
tfl2 <- spc2tfl(BrownInform.spc)
plot(tfl1, tfl2, log="xy", type="s",
legend=c("fiction", "non-fiction"), grid=TRUE)
plot(tfl1, tfl2, log="y", type="s",
legend=c("fiction", "non-fiction"), grid=TRUE)
plot(tfl1, tfl2, log="xy", type="s",
legend=c("fiction", "non-fiction"), grid=TRUE)
## show Zipf-Mandelbrot law fitted to low end of frequency spectrum
m1 <- lnre("zm", BrownInform.spc)
m2 <- lnre("fzm", BrownInform.spc)
plot(tfl1, tfl2, m1, m2, log="xy", type="s", freq=FALSE, grid=TRUE,
legend=c("fiction", "non-fiction", "ZM", "fZM"))
## call plot.tfl explicitly if only LNRE populations are displayed
plot.tfl(m1, m2, max.rank=1e5, freq=FALSE, log="xy")
## first argument can then also be a list of TFLs and/or LNRE models
plot.tfl(lapply(EvertLuedeling2001, vec2tfl), log="xy", type="s", freq=FALSE,
legend=names(EvertLuedeling2001))
## first argument can then also be a list of TFLs and/or LNRE models
plot.tfl(lapply(EvertLuedeling2001, vec2tfl), log="xy", type="s", freq=FALSE,
legend=names(EvertLuedeling2001))
## first argument can then also be a list of TFLs and/or LNRE models
plot.tfl(lapply(EvertLuedeling2001, vec2tfl), log="y", type="s", freq=FALSE,
legend=names(EvertLuedeling2001))
## first argument can then also be a list of TFLs and/or LNRE models
plot.tfl(lapply(EvertLuedeling2001, vec2tfl), log="xy", type="s", freq=FALSE,
legend=names(EvertLuedeling2001))
## load Oliver Twist and Great Expectations frequency spectra
data(DickensOliverTwist.spc)
data(DickensGreatExpectations.spc)
## check sample size and vocabulary and hapax counts
N(DickensOliverTwist.spc)
V(DickensOliverTwist.spc)
Vm(DickensOliverTwist.spc,1)
N(DickensGreatExpectations.spc)
V(DickensGreatExpectations.spc)
Vm(DickensGreatExpectations.spc,1)
## compute binomially interpolated growth curves
ot.vgc <- vgc.interp(DickensOliverTwist.spc,(1:100)*1570)
ge.vgc <- vgc.interp(DickensGreatExpectations.spc,(1:100)*1865)
## plot them
plot(ot.vgc,ge.vgc,legend=c("Oliver Twist","Great Expectations"))
install.packages("poweRlaw")
library(poweRlaw)
data(population)
population
plot(population,log="y")
plot(sort(population,decreasing = TRUE),log="y")
plot(sort(population,decreasing = TRUE),log="xy")
data(moby)
plot(sort(moby,decreasing = TRUE),log="xy")
plot(sort(moby,decreasing = TRUE),log="y")
plot(sort(moby,decreasing = TRUE),log="xy")
data("swiss_prot")
plot(sort(swiss_prot,decreasing = TRUE),log="xy")
swiss_prot
plot(sort(native_american,decreasing = TRUE),log="xy")
data("native_american")
native_american
head(native_american)
table(native_american)
head(table(native_american))
native_american
plot(sort(native_american$Cas,decreasing = TRUE),log="xy")
plot(sort(native_american$Cas,decreasing = TRUE),log="y")
plot(sort(native_american$Cas,decreasing = TRUE),log="xy")
plot(sort(native_american$Cas,decreasing = TRUE),log="y")
remove.packages("DGDB")
install.packages(c("digest", "ragg", "tidyselect"))
install.packages(c("digest", "ragg", "tidyselect"))
install.packages(c("digest", "ragg", "tidyselect"))
